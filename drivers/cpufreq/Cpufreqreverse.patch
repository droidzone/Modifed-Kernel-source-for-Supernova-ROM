--- bravo_2.6.35_gb-mr-works/drivers/cpufreq/cpufreq.c	2011-10-31 14:27:41.694713400 +0530
+++ bravo_2.6.35_gb-mr/drivers/cpufreq/cpufreq.c	2011-11-01 14:56:24.000000000 +0530
@@ -28,6 +28,7 @@
 #include <linux/cpu.h>
 #include <linux/completion.h>
 #include <linux/mutex.h>
+#include <linux/sched.h>
 
 #define dprintk(msg...) cpufreq_debug_printk(CPUFREQ_DEBUG_CORE, \
 						"cpufreq-core", msg)
@@ -666,6 +667,141 @@ static ssize_t show_bios_limit(struct cp
 	return sprintf(buf, "%u\n", policy->cpuinfo.max_freq);
 }
 
+#ifdef CONFIG_CPU_FREQ_VDD_LEVELS
+#ifdef CONFIG_MSM_CPU_AVS
+extern ssize_t acpuclk_get_vdd_levels_havs_str(char *buf);
+static ssize_t show_vdd_levels_havs(struct cpufreq_policy *policy, char *buf)
+{
+	return acpuclk_get_vdd_levels_havs_str(buf);
+}
+
+int	atoi(char *string) {
+  int	retCode=0;
+  int	sign=1;
+
+  while (*string != 0) {
+    if (*string=='+') {
+      sign=1;
+    } else if (*string=='-') {
+      sign=-1;
+    } else if ((*string>='0') && (*string<='9')) {
+      retCode *= 10;
+      retCode += *string-'0';
+    } else {
+      break;
+    }
+    string++;
+  }
+
+  retCode *= sign;
+
+  return (retCode);
+}
+
+#define	SEPARATORS	"\t :"
+extern void acpuclk_set_vdd_havs(unsigned acpu_khz, int min_vdd, int max_vdd);
+static ssize_t store_vdd_levels_havs(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+  char	*fields[3]={0};
+  int	f, nbFields=0;
+
+  fields[0]=(char *)buf;
+  for (f=0; (f<count) && (nbFields<3); f++) {
+    if (strchr(SEPARATORS, buf[f]) != NULL) {
+      // new field
+      nbFields++;
+      while ((strchr(SEPARATORS, buf[f])!=NULL) && (f<count)) {
+	f++;
+      }
+      fields[nbFields]=(char *)&buf[f];
+    }
+  }
+  if (f==count) {
+    nbFields++;
+  }
+
+  dprintk("nbFields=%d\n", nbFields);
+  for (f=0; f<nbFields; f++) {
+    dprintk("Field%d=%s - val=%d\n", f, fields[f], atoi(fields[f]));
+  }
+
+  // 2 possibilities. Either we have 2 fields containing +/- values.
+  // Either we have 3 fields containing the frequency, new min, and new max
+  if (nbFields==2) {
+    acpuclk_set_vdd_havs(0, atoi(fields[0]), atoi(fields[1]));
+  } else if (nbFields==3) {
+    acpuclk_set_vdd_havs(atoi(fields[0]), atoi(fields[1]), atoi(fields[2]));
+  }
+
+  return count;
+}
+#else
+extern ssize_t acpuclk_get_vdd_levels_str(char *buf);
+static ssize_t show_vdd_levels(struct cpufreq_policy *policy, char *buf)
+{
+	return acpuclk_get_vdd_levels_str(buf);
+}
+
+extern void acpuclk_set_vdd(unsigned acpu_khz, int vdd);
+static ssize_t store_vdd_levels(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	int i = 0, j;
+	int pair[2] = { 0, 0 };
+	int sign = 0;
+
+	if (count < 1)
+		return 0;
+
+	if (buf[0] == '-')
+	{
+		sign = -1;
+		i++;
+	}
+	else if (buf[0] == '+')
+	{
+		sign = 1;
+		i++;
+	}
+
+	for (j = 0; i < count; i++)
+	{
+		char c = buf[i];
+		if ((c >= '0') && (c <= '9'))
+		{
+			pair[j] *= 10;
+			pair[j] += (c - '0');
+		}
+		else if ((c == ' ') || (c == '\t'))
+		{
+			if (pair[j] != 0)
+			{
+				j++;
+				if ((sign != 0) || (j > 1))
+					break;
+			}
+		}
+		else
+			break;
+	}
+
+	if (sign != 0)
+	{
+		if (pair[0] > 0)
+			acpuclk_set_vdd(0, sign * pair[0]);
+	}
+	else
+	{
+		if ((pair[0] > 0) && (pair[1] > 0))
+			acpuclk_set_vdd((unsigned)pair[0], pair[1]);
+		else
+			return -EINVAL;
+	}
+
+	return count;
+}
+#endif // AVS
+#endif // VDD_LEVELS
+
 cpufreq_freq_attr_ro_perm(cpuinfo_cur_freq, 0400);
 cpufreq_freq_attr_ro(cpuinfo_min_freq);
 cpufreq_freq_attr_ro(cpuinfo_max_freq);
@@ -680,6 +816,13 @@ cpufreq_freq_attr_rw(scaling_min_freq);
 cpufreq_freq_attr_rw(scaling_max_freq);
 cpufreq_freq_attr_rw(scaling_governor);
 cpufreq_freq_attr_rw(scaling_setspeed);
+#ifdef CONFIG_CPU_FREQ_VDD_LEVELS
+#ifdef CONFIG_MSM_CPU_AVS
+cpufreq_freq_attr_rw(vdd_levels_havs);
+#else
+cpufreq_freq_attr_rw(vdd_levels);
+#endif // AVS
+#endif // VDD_LEVELS
 
 static struct attribute *default_attrs[] = {
 	&cpuinfo_min_freq.attr,
@@ -693,6 +836,13 @@ static struct attribute *default_attrs[]
 	&scaling_driver.attr,
 	&scaling_available_governors.attr,
 	&scaling_setspeed.attr,
+#ifdef CONFIG_CPU_FREQ_VDD_LEVELS
+#ifdef CONFIG_MSM_CPU_AVS
+	&vdd_levels_havs.attr,
+#else
+ 	&vdd_levels.attr,
+#endif // AVS
+#endif // VDD_LEVELS
 	NULL
 };
 
@@ -1051,8 +1201,8 @@ static int cpufreq_add_dev(struct sys_de
 		dprintk("initialization failed\n");
 		goto err_unlock_policy;
 	}
-	policy->user_policy.min = policy->min;
-	policy->user_policy.max = policy->max;
+	policy->user_policy.min = CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN;
+	policy->user_policy.max = CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX;
 
 	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
 				     CPUFREQ_START, policy);
@@ -1227,12 +1377,28 @@ static int __cpufreq_remove_dev(struct s
 		cpufreq_driver->exit(data);
 	unlock_policy_rwsem_write(cpu);
 
+	cpufreq_debug_enable_ratelimit();
+
+#ifdef CONFIG_HOTPLUG_CPU
+	/* when the CPU which is the parent of the kobj is hotplugged
+	 * offline, check for siblings, and create cpufreq sysfs interface
+	 * and symlinks
+	 */
+	if (unlikely(cpumask_weight(data->cpus) > 1)) {
+		/* first sibling now owns the new sysfs dir */
+		cpumask_clear_cpu(cpu, data->cpus);
+		cpufreq_add_dev(get_cpu_sysdev(cpumask_first(data->cpus)));
+
+		/* finally remove our own symlink */
+		lock_policy_rwsem_write(cpu);
+		__cpufreq_remove_dev(sys_dev);
+	}
+#endif
+
 	free_cpumask_var(data->related_cpus);
 	free_cpumask_var(data->cpus);
 	kfree(data);
-	per_cpu(cpufreq_cpu_data, cpu) = NULL;
 
-	cpufreq_debug_enable_ratelimit();
 	return 0;
 }
 
@@ -1549,6 +1715,12 @@ int __cpufreq_driver_target(struct cpufr
 		target_freq, relation);
 	if (cpu_online(policy->cpu) && cpufreq_driver->target)
 		retval = cpufreq_driver->target(policy, target_freq, relation);
+	if (likely(retval != -EINVAL)) {
+		if (target_freq == policy->max)
+			cpu_nonscaling(policy->cpu);
+		else
+			cpu_scaling(policy->cpu);
+	}
 
 	return retval;
 }
