From ba5491dde1f8d1aa4f5fc1acd1b35373f9dae157 Mon Sep 17 00:00:00 2001
From: bananacakes <tahitiisland03@gmail.com>
Date: Tue, 18 Oct 2011 08:42:28 -0300
Subject: [PATCH] Add: Vdd_havs

---
 arch/arm/mach-msm/Kconfig              |   23 ++
 arch/arm/mach-msm/Makefile             |    1 +
 arch/arm/mach-msm/acpuclock-scorpion.c |  120 +++++++--
 arch/arm/mach-msm/avs.c                |  460 ++++++++++++++++++++++++++++++++
 arch/arm/mach-msm/avs.h                |   94 +++++++
 arch/arm/mach-msm/avs_hw.S             |  132 +++++++++
 arch/arm/mach-msm/idle-v7.S            |   20 ++
 drivers/cpufreq/cpufreq.c              |  239 ++++++++++-------
 include/linux/cpufreq.h                |    2 +
 9 files changed, 979 insertions(+), 112 deletions(-)
 create mode 100644 arch/arm/mach-msm/avs.c
 create mode 100644 arch/arm/mach-msm/avs.h
 create mode 100644 arch/arm/mach-msm/avs_hw.S

diff --git a/arch/arm/mach-msm/Kconfig b/arch/arm/mach-msm/Kconfig
index 5f6a249..b4fdce5 100644
--- a/arch/arm/mach-msm/Kconfig
+++ b/arch/arm/mach-msm/Kconfig
@@ -752,6 +752,20 @@ config HTC_BATTCHG_SMEM
 	default n
 	bool "Read Battery Info via SMEM"
 
+config QSD_SVS
+	bool "QSD Static Voltage Scaling"
+	depends on (ARCH_MSM_SCORPION)
+	default y
+	help
+	  Enables static voltage scaling using the TPS65023 PMIC.
+
+config QSD_PMIC_DEFAULT_DCDC1
+	int "PMIC default output voltage"
+	depends on (ARCH_MSM_SCORPION)
+	default 1275
+	help
+	  This is the PMIC voltage at Linux kernel boot.
+
 config HTC_PWRSINK
 	depends on MSM_SMD
 	default y
@@ -1443,6 +1457,15 @@ config MSM_QDSP6
 	help
 	  Enable support for qdsp6. This provides audio and video functionality.
 
+config MSM_CPU_AVS
+	bool "Enable Adaptive Voltage Scaling (AVS)"
+	depends on (ARCH_MSM_SCORPION && QSD_SVS)
+	default n
+	help
+	  This enables the Adaptive Voltage Scaling feature of
+	  Qualcomm ARMv7 CPUs. It adjusts the voltage for each frequency
+	  based on feedback from three ring oscillators in the CPU.
+
 config MSM8X60_AUDIO
 	tristate "MSM8X60 audio support"
 	depends on ARCH_MSM8X60 && ANDROID_PMEM
diff --git a/arch/arm/mach-msm/Makefile b/arch/arm/mach-msm/Makefile
index 2b5cec6..9e6abf6 100644
--- a/arch/arm/mach-msm/Makefile
+++ b/arch/arm/mach-msm/Makefile
@@ -18,6 +18,7 @@ obj-$(CONFIG_ARCH_MSM7X30) += acpuclock-7x30.o internal_power_rail.o
 obj-$(CONFIG_ACPUCLOCK_DEBUG) += acpuclock_debug.o
 obj-$(CONFIG_ARCH_MSM7X30) += clock-7x30.o arch-init-7x30.o socinfo.o
 obj-$(CONFIG_ARCH_MSM7X30) += spm.o
+obj-$(CONFIG_MSM_CPU_AVS) += avs.o avs_hw.o
 
 ifdef CONFIG_ARCH_MSM8X60
 obj-$(CONFIG_CPU_V7) += idle-v7-8x60.o msm_fault_handlers.o
diff --git a/arch/arm/mach-msm/acpuclock-scorpion.c b/arch/arm/mach-msm/acpuclock-scorpion.c
index 51db8d0..b36ab62 100644
--- a/arch/arm/mach-msm/acpuclock-scorpion.c
+++ b/arch/arm/mach-msm/acpuclock-scorpion.c
@@ -22,17 +22,21 @@
 #include <linux/errno.h>
 #include <linux/cpufreq.h>
 #include <linux/regulator/consumer.h>
+#include <linux/regulator/driver.h>
 
 #include <mach/board.h>
 #include <mach/msm_iomap.h>
 
 #include "acpuclock.h"
+#include "avs.h"
 #include "proc_comm.h"
 #include "clock.h"
+
 #ifdef CONFIG_CPU_FREQ_VDD_LEVELS
 #include "board-bravo.h"
 #endif
 
+
 #if 0
 #define DEBUG(x...) pr_info(x)
 #else
@@ -62,6 +66,19 @@ struct clkctl_acpu_speed {
 	unsigned axiclk_khz;
 };
 
+static unsigned long max_axi_rate;
+
+struct regulator {
+	struct device *dev;
+	struct list_head list;
+	int uA_load;
+	int min_uV;
+	int max_uV;
+	char *supply_name;
+	struct device_attribute dev_attr;
+	struct regulator_dev *rdev;
+};
+
 /* clock sources */
 #define CLK_TCXO	0 /* 19.2 MHz */
 #define CLK_GLOBAL_PLL	1 /* 768 MHz */
@@ -142,7 +159,9 @@ static void __init acpuclk_init_cpufreq_table(void)
 			continue;
 		}
 
-		freq_table[i].frequency = acpu_freq_tbl[i].acpu_khz;
+		/* Take the fastest speed available at the specified VDD level */
+		/*if (vdd != acpu_freq_tbl[i + 1].vdd)*/
+			freq_table[i].frequency = acpu_freq_tbl[i].acpu_khz;
 	}
 
 	freq_table[i].index = i;
@@ -164,6 +183,7 @@ struct clock_state {
 	unsigned long			wait_for_irq_khz;
 	struct clk*			clk_ebi1;
 	struct regulator                *regulator;
+	int (*acpu_set_vdd) (int mvolts);
 };
 
 static struct clock_state drv_state = { 0 };
@@ -244,7 +264,7 @@ static void scpll_set_freq(uint32_t lval)
 			;
 
 		/* completion bit is not reliable for SHOT switch */
-		udelay(25);
+		udelay(15);
 	}
 
 	/* write the new L val and switch mode */
@@ -287,27 +307,41 @@ static void select_clock(unsigned src, unsigned config)
 	writel(val | ((src & 3) << 1), SPSS_CLK_SEL_ADDR);
 }
 
-static int acpuclk_set_vdd_level(int vdd)
+static int acpu_set_vdd(int vdd)
 {
 	if (!drv_state.regulator || IS_ERR(drv_state.regulator)) {
 		drv_state.regulator = regulator_get(NULL, "acpu_vcore");
 		if (IS_ERR(drv_state.regulator)) {
-			pr_info("acpuclk_set_vdd_level %d no regulator\n", vdd);
+			pr_info("acpu_set_vdd %d no regulator\n", vdd);
 			/* Assume that the PMIC supports scaling the processor
 			 * to its maximum frequency at its default voltage.
 			 */
-			return 0;
+			return -ENODEV;
 		}
-		pr_info("acpuclk_set_vdd_level got regulator\n");
+		pr_info("acpu_set_vdd got regulator\n");
 	}
 	vdd *= 1000; /* mV -> uV */
 	return regulator_set_voltage(drv_state.regulator, vdd, vdd);
 }
 
+static int acpuclk_set_vdd_level(int vdd)
+{
+	if (drv_state.acpu_set_vdd)
+		return drv_state.acpu_set_vdd(vdd);
+	else {
+		/* Assume that the PMIC supports scaling the processor
+		 * to its maximum frequency at its default voltage.
+		 */
+		return 0;
+	}
+}
+
 int acpuclk_set_rate(unsigned long rate, enum setrate_reason reason)
 {
 	struct clkctl_acpu_speed *cur, *next;
 	unsigned long flags;
+	int rc = 0;
+	int freq_index = 0;
 
 	cur = drv_state.current_speed;
 
@@ -316,7 +350,7 @@ int acpuclk_set_rate(unsigned long rate, enum setrate_reason reason)
 
 	DEBUG("acpuclk_set_rate(%d,%d)\n", (int) rate, reason);
 
-	if (rate == cur->acpu_khz || rate == 0)
+	if (rate == 0 || rate == cur->acpu_khz)
 		return 0;
 
 	next = acpu_freq_tbl;
@@ -326,16 +360,29 @@ int acpuclk_set_rate(unsigned long rate, enum setrate_reason reason)
 		if (next->acpu_khz == 0)
 			return -EINVAL;
 		next++;
+		freq_index++;
 	}
 
 	if (reason == SETRATE_CPUFREQ) {
 		mutex_lock(&drv_state.lock);
+#ifdef CONFIG_MSM_CPU_AVS
+               /* Notify avs before changing frequency */
+               rc = avs_adjust_freq(freq_index, 1);
+               if (rc) {
+                       printk(KERN_ERR
+                               "acpuclock: Unable to increase ACPU "
+                               "vdd: %d.\n", (int) rate);
+                       mutex_unlock(&drv_state.lock);
+                       return rc;
+               }
+#endif
 		/* Increase VDD if needed. */
 		if (next->vdd > cur->vdd) {
-			if (acpuclk_set_vdd_level(next->vdd)) {
+			rc = acpuclk_set_vdd_level(next->vdd);
+			if (rc) {
 				pr_err("acpuclock: Unable to increase ACPU VDD.\n");
 				mutex_unlock(&drv_state.lock);
-				return -EINVAL;
+				return rc;
 			}
 		}
 	}
@@ -377,9 +424,17 @@ int acpuclk_set_rate(unsigned long rate, enum setrate_reason reason)
 	}
 #endif
 	if (reason == SETRATE_CPUFREQ) {
+#ifdef CONFIG_MSM_CPU_AVS
+               /* notify avs after changing frequency */
+               rc = avs_adjust_freq(freq_index, 0);
+               if (rc)
+                       printk(KERN_ERR
+                               "acpuclock: Unable to drop ACPU vdd: %d.\n", (int) rate);
+#endif
 		/* Drop VDD level if we can. */
 		if (next->vdd < cur->vdd) {
-			if (acpuclk_set_vdd_level(next->vdd))
+			rc= acpuclk_set_vdd_level(next->vdd);
+			if (rc)
 				pr_err("acpuclock: Unable to drop ACPU VDD.\n");
 		}
 		mutex_unlock(&drv_state.lock);
@@ -442,6 +497,8 @@ void __init acpu_freq_tbl_fixup(void)
 		break;
 	case 0x30:
 	case 0x00:
+		max_acpu_khz = 998400;
+		break;
 	case 0x10:
 		max_acpu_khz = 1190400;
 		break;
@@ -465,7 +522,7 @@ skip_efuse_fixup:
 
 static void __init acpuclk_init(void)
 {
-	struct clkctl_acpu_speed *speed;
+	struct clkctl_acpu_speed *speed, *max_s;
 	unsigned init_khz;
 
 	init_khz = acpuclk_find_speed();
@@ -485,15 +542,15 @@ static void __init acpuclk_init(void)
 		BUG();
 	}
 
-	/* Move to 768MHz for boot, which is a safe frequency
+	/* Move to 998MHz for boot, which is a safe frequency
 	 * for all versions of Scorpion at the moment.
 	 */
 	speed = acpu_freq_tbl;
 	for (;;) {
-		if (speed->acpu_khz == 768000)
+		if (speed->acpu_khz == 998400)
 			break;
 		if (speed->acpu_khz == 0) {
-			pr_err("acpuclk_init: cannot find 768MHz\n");
+			pr_err("acpuclk_init: cannot find 998MHz\n");
 			BUG();
 		}
 		speed++;
@@ -518,8 +575,11 @@ static void __init acpuclk_init(void)
 
 	loops_per_jiffy = drv_state.current_speed->lpj;
 
-	speed = acpu_freq_tbl + ARRAY_SIZE(acpu_freq_tbl) - 2;
-	max_axi_rate = speed->axiclk_khz * 1000;
+	for (speed = acpu_freq_tbl; speed->acpu_khz != 0; speed++)
+		;
+
+	max_s = speed - 1;
+	max_axi_rate = max_s->axiclk_khz * 1000;
 }
 
 unsigned long acpuclk_get_max_axi_rate(void)
@@ -560,6 +620,23 @@ unsigned long acpuclk_wait_for_irq(void)
 	return ret * 1000;
 }
 
+#ifdef CONFIG_MSM_CPU_AVS
+static int __init acpu_avs_init(int (*set_vdd) (int), int khz)
+{
+	int i;
+	int freq_count = 0;
+	int freq_index = -1;
+
+	for (i = 0; acpu_freq_tbl[i].acpu_khz; i++) {
+		freq_count++;
+		if (acpu_freq_tbl[i].acpu_khz == khz)
+			freq_index = i;
+	}
+
+	return avs_init(set_vdd, freq_count, freq_index);
+}
+#endif
+
 void __init msm_acpu_clock_init(struct msm_acpu_clock_platform_data *clkdata)
 {
 	spin_lock_init(&acpu_lock);
@@ -570,20 +647,27 @@ void __init msm_acpu_clock_init(struct msm_acpu_clock_platform_data *clkdata)
 	drv_state.vdd_switch_time_us = clkdata->vdd_switch_time_us;
 	drv_state.power_collapse_khz = clkdata->power_collapse_khz;
 	drv_state.wait_for_irq_khz = clkdata->wait_for_irq_khz;
+	drv_state.acpu_set_vdd = acpu_set_vdd;
 
 	if (clkdata->mpll_khz)
 		acpu_mpll->acpu_khz = clkdata->mpll_khz;
 
-	acpu_freq_tbl_fixup();
 	acpuclk_init();
 	acpuclk_init_cpufreq_table();
 	drv_state.clk_ebi1 = clk_get(NULL,"ebi1_clk");
 #ifndef CONFIG_AXI_SCREEN_POLICY
 	clk_set_rate(drv_state.clk_ebi1, drv_state.current_speed->axiclk_khz * 1000);
 #endif
+#ifdef CONFIG_MSM_CPU_AVS
+       if (!acpu_avs_init(drv_state.acpu_set_vdd,
+               drv_state.current_speed->acpu_khz)) {
+               /* avs init successful. avs will handle voltage changes */
+               drv_state.acpu_set_vdd = NULL;
+       }
+#endif
 }
 
-#ifdef CONFIG_CPU_FREQ_VDD_LEVELS
+#if defined(CONFIG_CPU_FREQ_VDD_LEVELS) && !defined(CONFIG_MSM_CPU_AVS)
 
 ssize_t acpuclk_get_vdd_levels_str(char *buf)
 {
diff --git a/arch/arm/mach-msm/avs.c b/arch/arm/mach-msm/avs.c
new file mode 100644
index 0000000..7a62ff7
--- /dev/null
+++ b/arch/arm/mach-msm/avs.c
@@ -0,0 +1,460 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Code Aurora Forum nor
+ *       the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this software
+ * may be relicensed by the recipient under the terms of the GNU General Public
+ * License version 2 ("GPL") and only version 2, in which case the provisions of
+ * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+ * software under the GPL, then the identification text in the MODULE_LICENSE
+ * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+ * recipient changes the license terms to the GPL, subsequent recipients shall
+ * not relicense under alternate licensing terms, including the BSD or dual
+ * BSD/GPL terms.  In addition, the following license statement immediately
+ * below and between the words START and END shall also then apply when this
+ * software is relicensed under the GPL:
+ *
+ * START
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 and only version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * END
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/kernel_stat.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+
+#ifdef CONFIG_CPU_FREQ_VDD_LEVELS
+#include "board-bravo.h"
+#endif
+
+#include "avs.h"
+
+#define AVSDSCR_INPUT 0x01004860 /* magic # from circuit designer */
+#define TSCSR_INPUT   0x00000001 /* enable temperature sense */
+
+#define TEMPRS 16                /* total number of temperature regions */
+#define GET_TEMPR() (avs_get_tscsr() >> 28) /* scale TSCSR[CTEMP] to regions */
+
+struct mutex avs_lock;
+
+static struct avs_state_s
+{
+	u32 freq_cnt;		/* Frequencies supported list */
+	short *avs_v;		/* Dyanmically allocated storage for
+				 * 2D table of voltages over temp &
+				 * freq.  Used as a set of 1D tables.
+				 * Each table is for a single temp.
+				 * For usage see avs_get_voltage
+				 */
+	int (*set_vdd) (int);	/* Function Ptr for setting voltage */
+	int changing;		/* Clock frequency is changing */
+	u32 freq_idx;		/* Current frequency index */
+	int vdd;		/* Current ACPU voltage */
+} avs_state;
+
+struct clkctl_acpu_speed {
+  unsigned	acpu_khz;
+  int		min_vdd;
+  int		max_vdd;
+};
+
+#ifndef MAX
+#define MAX(A,B) (A>B?A:B)
+#endif // !ndef MAX
+
+struct clkctl_acpu_speed acpu_vdd_tbl[] = {
+	{  19200, VOLTAGE_MIN_START, 1025},
+	{ 128000, VOLTAGE_MIN_START, 1025 },
+	{ 245000, VOLTAGE_MIN_START, 1050 },
+	{ 384000, VOLTAGE_MIN_START, 1050 },
+ 	{ 422400, VOLTAGE_MIN_START, 1050 },
+	{ 460800, VOLTAGE_MIN_START, 1050 },
+	{ 499200, MAX(VOLTAGE_MIN_START,900), 1075 },
+	{ 537600, MAX(VOLTAGE_MIN_START,900), 1100 },
+	{ 576000, MAX(VOLTAGE_MIN_START,950), 1100 },
+	{ 614400, MAX(VOLTAGE_MIN_START,950), 1125 },
+	{ 652800, MAX(VOLTAGE_MIN_START,950), 1150 },
+	{ 691200, MAX(VOLTAGE_MIN_START,975), 1175 },
+	{ 729600, MAX(VOLTAGE_MIN_START,975), 1200 },
+	{ 768000, MAX(VOLTAGE_MIN_START,975), 1200 },
+	{ 806400, 1220, 1225 },
+	{ 844800, 1225, 1250 },
+	{ 883200, 1250, 1275 },
+	{ 921600, 1250, 1275 },
+	{ 960000, 1250, 1275 },
+	{ 998400, 1250, 1275 },
+#ifdef	USE_OVERCLOCKING
+	{ 1036800, 1250, 1275 },
+	{ 1075200, 1250, 1275 },
+	{ 1113600, 1275, 1300 },
+//#endif
+//#ifdef	USE_EXTREMEOVERCLOCKING
+	{ 1152000, 1250, 1300 },
+	{ 1190400, 1250, 1300 },
+#endif
+	{ 0 },
+};
+
+#if defined(CONFIG_CPU_FREQ_VDD_LEVELS) && defined(CONFIG_MSM_CPU_AVS)
+ssize_t acpuclk_get_vdd_levels_havs_str(char *buf)
+{
+	int i, len = 0;
+	if (buf)
+	{
+	  for (i = 0; acpu_vdd_tbl[i].acpu_khz; i++) 
+	    {
+	      len += sprintf(buf + len, "%8u: %4d %4d\n", acpu_vdd_tbl[i].acpu_khz, acpu_vdd_tbl[i].min_vdd, acpu_vdd_tbl[i].max_vdd);
+	    }
+	}
+	return len;
+}
+
+void acpuclk_set_vdd_havs(unsigned acpu_khz, int min_vdd, int max_vdd    ) {
+  int i;
+  min_vdd = min_vdd / 25 * 25;	//! regulator only accepts multiples of 25 (mV)
+  max_vdd=max_vdd/25*25;
+
+  mutex_lock(&avs_lock);
+ 
+  for (i = 0; acpu_vdd_tbl[i].acpu_khz; i++) {
+    if (acpu_khz == 0) {
+      acpu_vdd_tbl[i].min_vdd = min(max((acpu_vdd_tbl[i].min_vdd + min_vdd), BRAVO_TPS65023_MIN_UV_MV), BRAVO_TPS65023_MAX_UV_MV);
+      acpu_vdd_tbl[i].max_vdd = min(max((acpu_vdd_tbl[i].max_vdd + max_vdd), BRAVO_TPS65023_MIN_UV_MV), BRAVO_TPS65023_MAX_UV_MV);
+    } else if (acpu_vdd_tbl[i].acpu_khz == acpu_khz) {
+      acpu_vdd_tbl[i].min_vdd = min(max(min_vdd, BRAVO_TPS65023_MIN_UV_MV), BRAVO_TPS65023_MAX_UV_MV);
+      acpu_vdd_tbl[i].max_vdd = min(max(max_vdd, BRAVO_TPS65023_MIN_UV_MV), BRAVO_TPS65023_MAX_UV_MV);
+    }
+  }
+
+  /*  for (i = 0; i < TEMPRS*avs_state.freq_cnt; i++) {
+    avs_state.avs_v[i] = VOLTAGE_MAX;
+    }*/
+
+  avs_reset_delays(AVSDSCR_INPUT);
+  avs_set_tscsr(TSCSR_INPUT);
+  //avs_state.changing = 0;
+  //avs_state.freq_idx = -1;
+  //avs_state.vdd = -1;
+  //avs_adjust_freq(freq_idx, 0);
+  
+  mutex_unlock(&avs_lock);
+}
+
+#endif // CONFIG_CPU_FREQ_VDD_LEVELS
+
+static int avs_debug = 0;
+module_param(avs_debug, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(avs_debug, "Toggle AVS debug printout");
+
+/*
+ *  Update the AVS voltage vs frequency table, for current temperature
+ *  Adjust based on the AVS delay circuit hardware status
+ */
+static void avs_update_voltage_table(short *vdd_table)
+{
+	u32 avscsr;
+	int cpu;
+	int vu;
+	int l2;
+	int i;
+	u32 cur_freq_idx;
+	short cur_voltage;
+
+	cur_freq_idx = avs_state.freq_idx;
+	cur_voltage = avs_state.vdd;
+
+	avscsr = avs_test_delays();
+	AVSDEBUG("vdd_table=0x%X\n", (unsigned int)vdd_table);
+	AVSDEBUG("avscsr=%x, avsdscr=%x, cur_voltage=%d\n", avscsr, avs_get_avsdscr(), cur_voltage);
+
+	/*
+	 * Read the results for the various unit's AVS delay circuits
+	 * 2=> up, 1=>down, 0=>no-change
+	 */
+	cpu = ((avscsr >> 23) & 2) + ((avscsr >> 16) & 1);
+	vu  = ((avscsr >> 28) & 2) + ((avscsr >> 21) & 1);
+	l2  = ((avscsr >> 29) & 2) + ((avscsr >> 22) & 1);
+	AVSDEBUG("cpu=%d, vu=%d, l2=%d\n", cpu, vu, l2);
+
+	if ((cpu == 3) || (vu == 3) || (l2 == 3)) {
+		printk(KERN_ERR "AVS: Dly Synth O/P error\n");
+	} else if ((cpu == 2) || (l2 == 2) || (vu == 2)) {
+		/*
+		 * even if one oscillator asks for up, increase the voltage,
+		 * as its an indication we are running outside the
+		 * critical acceptable range of v-f combination.
+		 */
+		AVSDEBUG("cpu=%d l2=%d vu=%d\n", cpu, l2, vu);
+		AVSDEBUG("Voltage up at %d\n", cur_freq_idx);
+
+		if (cur_voltage >= VOLTAGE_MAX || cur_voltage >= acpu_vdd_tbl[cur_freq_idx].max_vdd)
+			if (avs_debug)
+				printk(KERN_ERR
+					"AVS: Voltage can not get high enough!\n");
+
+		/* Raise the voltage for all frequencies */
+		for (i = 0; i < avs_state.freq_cnt; i++) {
+			vdd_table[i] = cur_voltage + VOLTAGE_STEP;
+			if (vdd_table[i] > VOLTAGE_MAX)
+				vdd_table[i] = VOLTAGE_MAX;
+			else if (vdd_table[i] > acpu_vdd_tbl[i].max_vdd)
+				vdd_table[i] = acpu_vdd_tbl[i].max_vdd;
+		}
+	} else if ((cpu == 1) && (l2 == 1) && (vu == 1)) {
+	  AVSDEBUG("cur_voltage=%d, min_vdd=%d, vdd_table=%d\n", cur_voltage, acpu_vdd_tbl[cur_freq_idx].min_vdd, vdd_table[cur_freq_idx]);
+		if ((cur_voltage - VOLTAGE_STEP >= VOLTAGE_MIN) &&
+		    (cur_voltage - VOLTAGE_STEP >= acpu_vdd_tbl[cur_freq_idx].min_vdd) &&
+		    (cur_voltage <= vdd_table[cur_freq_idx])) {
+			vdd_table[cur_freq_idx] = cur_voltage - VOLTAGE_STEP;
+			AVSDEBUG("Voltage down for %d and lower levels\n",
+				cur_freq_idx);
+
+			/* clamp to this voltage for all lower levels */
+			for (i = 0; i < cur_freq_idx; i++) {
+				if (vdd_table[i] > vdd_table[cur_freq_idx])
+					vdd_table[i] = vdd_table[cur_freq_idx];
+			}
+		}
+	}
+}
+
+/*
+ * Return the voltage for the target performance freq_idx and optionally
+ * use AVS hardware to check the present voltage freq_idx
+ */
+static short avs_get_target_voltage(int freq_idx, bool update_table)
+{
+	unsigned	cur_tempr = GET_TEMPR();
+	unsigned	temp_index = cur_tempr*avs_state.freq_cnt;
+	short		*vdd_table;
+
+	/* Table of voltages vs frequencies for this temp */
+	vdd_table = avs_state.avs_v + temp_index;
+
+	AVSDEBUG("vdd_table[%d]=%d\n", freq_idx, vdd_table[freq_idx]);
+	if ((update_table) || (vdd_table[freq_idx]==VOLTAGE_MAX)) {
+	  avs_update_voltage_table(vdd_table);
+	}
+
+	if (vdd_table[freq_idx] > acpu_vdd_tbl[freq_idx].max_vdd) {
+		if (avs_debug)
+			printk("%dmV too high for %d.\n", vdd_table[freq_idx], acpu_vdd_tbl[freq_idx].acpu_khz);
+		vdd_table[freq_idx] = acpu_vdd_tbl[freq_idx].max_vdd;
+	}
+	if (vdd_table[freq_idx] < acpu_vdd_tbl[freq_idx].min_vdd) {
+		if (avs_debug)
+			printk("%dmV too low for %d.\n", vdd_table[freq_idx], acpu_vdd_tbl[freq_idx].acpu_khz);
+		vdd_table[freq_idx] = acpu_vdd_tbl[freq_idx].min_vdd;
+	}
+
+	return vdd_table[freq_idx];
+}
+
+
+/*
+ * Set the voltage for the freq_idx and optionally
+ * use AVS hardware to update the voltage
+ */
+static int avs_set_target_voltage(int freq_idx, bool update_table)
+{
+	int ctr = 5, rc = 0, new_voltage;
+
+	if (freq_idx < 0 || freq_idx >= avs_state.freq_cnt) {
+		AVSDEBUG("Out of range :%d\n", freq_idx);
+		return -EINVAL;
+	}
+
+	new_voltage = avs_get_target_voltage(freq_idx, update_table);
+	if (avs_state.vdd != new_voltage) {
+		if (avs_debug)
+			printk("AVS setting V to %d mV @%d MHz\n",
+				new_voltage, acpu_vdd_tbl[freq_idx].acpu_khz / 1000);
+		rc = avs_state.set_vdd(new_voltage);
+		while (rc && ctr) {
+			rc = avs_state.set_vdd(new_voltage);
+			ctr--;
+			if (rc) {
+				if (avs_debug)
+					printk(KERN_ERR "avs_set_target_voltage: Unable to set V to %d mV (attempt: %d)\n", new_voltage, 5 - ctr);
+				mdelay(1);
+			}
+		}
+		if (rc)
+			return rc;
+		avs_state.vdd = new_voltage;
+	}
+	return rc;
+}
+
+/*
+ * Notify avs of clk frquency transition begin & end
+ */
+int avs_adjust_freq(u32 freq_idx, int begin)
+{
+	int rc = 0;
+
+	if (!avs_state.set_vdd) {
+		/* AVS not initialized */
+		return 0;
+	}
+
+	if (freq_idx < 0 || freq_idx >= avs_state.freq_cnt) {
+		if (avs_debug)
+			printk("Out of range :%d\n", freq_idx);
+		return -EINVAL;
+	}
+
+	mutex_lock(&avs_lock);
+	if ((begin && (freq_idx > avs_state.freq_idx)) ||
+	    (!begin && (freq_idx < avs_state.freq_idx))) {
+		/* Update voltage before increasing frequency &
+		 * after decreasing frequency
+		 */
+		rc = avs_set_target_voltage(freq_idx, 0);
+		if (rc)
+			goto aaf_out;
+
+		avs_state.freq_idx = freq_idx;
+	}
+	avs_state.changing = begin;
+aaf_out:
+	mutex_unlock(&avs_lock);
+
+	return rc;
+}
+
+
+static struct delayed_work avs_work;
+static struct workqueue_struct  *kavs_wq;
+#define AVS_DELAY ((CONFIG_HZ * 50 + 999) / 1000)
+
+static void do_avs_timer(struct work_struct *work)
+{
+	int cur_freq_idx;
+
+	mutex_lock(&avs_lock);
+	if (!avs_state.changing) {
+		/* Only adjust the voltage if clk is stable */
+		cur_freq_idx = avs_state.freq_idx;
+		avs_set_target_voltage(cur_freq_idx, 1);
+	}
+	mutex_unlock(&avs_lock);
+	queue_delayed_work_on(0, kavs_wq, &avs_work, AVS_DELAY);
+}
+
+
+static void __init avs_timer_init(void)
+{
+	INIT_DELAYED_WORK_DEFERRABLE(&avs_work, do_avs_timer);
+	queue_delayed_work_on(0, kavs_wq, &avs_work, AVS_DELAY);
+}
+
+static void __exit avs_timer_exit(void)
+{
+	cancel_delayed_work(&avs_work);
+}
+
+static int __init avs_work_init(void)
+{
+	kavs_wq = create_workqueue("avs");
+	if (!kavs_wq) {
+		printk(KERN_ERR "AVS initialization failed\n");
+		return -EFAULT;
+	}
+	avs_timer_init();
+
+	return 1;
+}
+
+static void __exit avs_work_exit(void)
+{
+	avs_timer_exit();
+	destroy_workqueue(kavs_wq);
+}
+
+int __init avs_init(int (*set_vdd)(int), u32 freq_cnt, u32 freq_idx)
+{
+	int i;
+
+	mutex_init(&avs_lock);
+
+	if (freq_cnt == 0)
+		return -EINVAL;
+
+	avs_state.freq_cnt = freq_cnt;
+
+	if (freq_idx >= avs_state.freq_cnt)
+		return -EINVAL;
+
+	avs_state.avs_v = kmalloc(TEMPRS * avs_state.freq_cnt *
+		sizeof(avs_state.avs_v[0]), GFP_KERNEL);
+
+	if (avs_state.avs_v == 0)
+		return -ENOMEM;
+
+	for (i = 0; i < TEMPRS*avs_state.freq_cnt; i++)
+		avs_state.avs_v[i] = VOLTAGE_MAX;
+
+	avs_reset_delays(AVSDSCR_INPUT);
+	avs_set_tscsr(TSCSR_INPUT);
+
+	avs_state.set_vdd = set_vdd;
+	avs_state.changing = 0;
+	avs_state.freq_idx = -1;
+	avs_state.vdd = -1;
+	avs_adjust_freq(freq_idx, 0);
+
+	avs_work_init();
+
+	return 0;
+}
+
+void __exit avs_exit()
+{
+	avs_work_exit();
+
+	kfree(avs_state.avs_v);
+}
+
+
diff --git a/arch/arm/mach-msm/avs.h b/arch/arm/mach-msm/avs.h
new file mode 100644
index 0000000..313585a
--- /dev/null
+++ b/arch/arm/mach-msm/avs.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef AVS_H
+#define AVS_H
+
+//#define VOLTAGE_MIN  800 /* mV */
+//#define VOLTAGE_MAX  1300
+
+#include "board-bravo.h"
+
+#define	USE_OVERCLOCKING 1
+//#define	USE_EXTREMEOVERCLOCKING	1
+
+#define VOLTAGE_MIN  BRAVO_TPS65023_MIN_UV_MV /* mV */
+#define VOLTAGE_MAX  BRAVO_TPS65023_MAX_UV_MV
+#define	VOLTAGE_MIN_START	900	// Minimum value to start off with
+#define VOLTAGE_STEP 25
+
+int __init avs_init(int (*set_vdd)(int), u32 freq_cnt, u32 freq_idx);
+void __exit avs_exit(void);
+
+int avs_adjust_freq(u32 freq_index, int begin);
+
+/* Routines exported from avs_hw.S */
+#ifdef CONFIG_MSM_CPU_AVS
+u32 avs_test_delays(void);
+#else
+static inline u32 avs_test_delays(void)
+{ return 0; }
+#endif
+
+#ifdef CONFIG_MSM_AVS_HW
+u32 avs_reset_delays(u32 avsdscr);
+u32 avs_get_avscsr(void);
+u32 avs_get_avsdscr(void);
+u32 avs_get_tscsr(void);
+void avs_set_tscsr(u32 to_tscsr);
+void avs_disable(void);
+#else
+static inline u32 avs_reset_delays(u32 avsdscr)
+{ return 0; }
+static inline u32 avs_get_avscsr(void)
+{ return 0; }
+static inline u32 avs_get_avsdscr(void)
+{ return 0; }
+static inline u32 avs_get_tscsr(void)
+{ return 0; }
+static inline void avs_set_tscsr(u32 to_tscsr) {}
+static inline void avs_disable(void) {}
+#endif
+
+/*#define AVSDEBUG(x...) pr_info("AVS: " x);*/
+#define AVSDEBUG(...)
+
+#define AVS_DISABLE(cpu) do {			\
+		if (get_cpu() == (cpu))		\
+			avs_disable();		\
+		put_cpu();			\
+	} while (0);
+
+#define AVS_ENABLE(cpu, x) do {			\
+		if (get_cpu() == (cpu))		\
+			avs_reset_delays((x));	\
+		put_cpu();			\
+	} while (0);
+
+#endif /* AVS_H */
diff --git a/arch/arm/mach-msm/avs_hw.S b/arch/arm/mach-msm/avs_hw.S
new file mode 100644
index 0000000..5e1530e
--- /dev/null
+++ b/arch/arm/mach-msm/avs_hw.S
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ */
+
+	.text
+
+#ifdef CONFIG_MSM_CPU_AVS
+	.global avs_test_delays
+avs_test_delays:
+
+/*      Read r1=CPMR and enable Never Sleep for VSLPDLY */
+		mrc  p15, 7, r1, c15, c0, 5
+		orr  r12, r1, #3, 24
+		mcr  p15, 7, r12, c15, c0, 5
+
+/*      Read r2=CPACR and enable full access to CP10 and CP11 space */
+		mrc p15, 0, r2, c1, c0, 2
+		orr r12, r2, #(0xf << 20)
+		mcr p15, 0, r12, c1, c0, 2
+		isb
+
+/*      Read r3=FPEXC and or in FP enable, VFP/ASE enable = FPEXC[30]; */
+		fmrx r3, fpexc
+		orr  r12, r3, #1, 2
+		fmxr fpexc, r12
+
+/*
+ *      Do floating-point operations to prime the VFP pipeline.   Use
+ *      fcpyd d0, d0 as a floating point nop.  This avoids changing VFP
+ *      state.
+ */
+		fcpyd d0, d0
+		fcpyd d0, d0
+		fcpyd d0, d0
+
+/*      Read r0=AVSCSR to get status from CPU, VFP, and L2 ring oscillators */
+		mrc p15, 7, r0, c15, c1, 7
+
+/*      Restore FPEXC */
+		fmxr fpexc, r3
+
+/*      Restore CPACR */
+                MCR p15, 0, r2, c1, c0, 2
+
+/*      Restore CPMR */
+		mcr p15, 7, r1, c15, c0, 5
+                isb
+
+		bx lr
+#endif
+
+
+	.global avs_get_avscsr
+/*      Read r0=AVSCSR to get status from CPU, VFP, and L2 ring oscillators */
+
+avs_get_avscsr:
+		mrc p15, 7, r0, c15, c1, 7
+                bx lr
+
+        .global avs_get_avsdscr
+/*      Read r0=AVSDSCR to get the AVS Delay Synthesizer control settings */
+
+avs_get_avsdscr:
+		mrc p15, 7, r0, c15, c0, 6
+                bx lr
+
+
+
+
+	.global avs_get_tscsr
+/*      Read r0=TSCSR to get temperature sensor control and status */
+
+avs_get_tscsr:
+		mrc p15, 7, r0, c15, c1, 0
+                bx lr
+
+        .global avs_set_tscsr
+/*      Write TSCSR=r0 to set temperature sensor control and status  */
+
+avs_set_tscsr:
+		mcr p15, 7, r0, c15, c1, 0
+                bx lr
+
+
+
+
+
+	.global avs_reset_delays
+avs_reset_delays:
+
+/*      AVSDSCR(dly) to program delay */
+		mcr p15, 7, r0, c15, c0, 6
+
+/*      Read r0=AVSDSCR */
+		mrc p15, 7, r0, c15, c0, 6
+
+/*      AVSCSR(0x61) to enable CPU, V and L2 AVS module  */
+		mov r3, #0x61
+		mcr p15, 7, r3, c15, c1, 7
+
+		bx lr
+
+
+
+        .global avs_disable
+avs_disable:
+
+/*      Clear AVSCSR */
+		mov r0, #0
+
+/*      Write AVSCSR */
+		mcr p15, 7, r0, c15, c1, 7
+
+		bx lr
+
+	.end
+
+
diff --git a/arch/arm/mach-msm/idle-v7.S b/arch/arm/mach-msm/idle-v7.S
index bfad22c..3d22670 100644
--- a/arch/arm/mach-msm/idle-v7.S
+++ b/arch/arm/mach-msm/idle-v7.S
@@ -41,6 +41,17 @@ ENTRY(msm_pm_collapse)
 	mrc     p15, 0, r9, c13, c0, 3 /* TPIDRURO */
 	mrc     p15, 0, ip, c13, c0, 1 /* context ID */
 	stmia   r0!, {r1-r9, ip}
+#ifdef CONFIG_MSM_CPU_AVS
+       mrc     p15, 7, r1, c15, c1, 7 /* AVSCSR is the Adaptive Voltage Scaling
+                                       * Control and Status Register */
+       mrc     p15, 7, r2, c15, c0, 6 /* AVSDSCR is the Adaptive Voltage
+                                       * Scaling Delay Synthesizer Control
+                                       * Register */
+       mrc     p15, 7, r3, c15, c1, 0 /* TSCSR is the Temperature Status and
+                                       * Control Register
+                                       */
+       stmia   r0!, {r1-r3}
+#endif
 
 #ifdef CONFIG_VFP
 	VFPFSTMIA r0, r1              /* Save VFP working registers */
@@ -111,6 +122,12 @@ _cpu_early_init_complete:
 	adr     r3, msm_pm_collapse_exit
 	add     r1, r1, r3
 	sub     r1, r1, r2
+#ifdef CONFIG_MSM_CPU_AVS
+	ldmdb   r1!, {r2-r4}
+	mcr     p15, 7, r4, c15, c1, 0 /* TSCSR */
+	mcr     p15, 7, r3, c15, c0, 6 /* AVSDSCR */
+	mcr     p15, 7, r2, c15, c1, 7 /* AVSCSR */
+#endif
 #ifdef CONFIG_VFP
 	mrc     p15, 0, r2, c1, c0, 2 /* Read CP Access Control Register */
 	orr     r2, r2, #0x00F00000   /* Enable full access for p10,11 */
@@ -194,6 +211,9 @@ msm_pm_pa_to_va:
 saved_state:
 	.space  4 * 11 /* r4-14 */
 	.space  4 * 10  /* cp15 */
+#ifdef CONFIG_MSM_CPU_AVS
+	.space  4 * 3  /* AVS control registers */
+#endif
 #ifdef CONFIG_VFP
 	.space  8 * 32 /* VFP working registers */
 	.space  4 * 2  /* VFP state registers */
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index a51063e..b003b35 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -652,106 +652,155 @@ static ssize_t show_scaling_setspeed(struct cpufreq_policy *policy, char *buf)
 	return policy->governor->show_setspeed(policy, buf);
 }
 
-#ifdef CONFIG_CPU_FREQ_VDD_LEVELS
+/**
+ * show_scaling_driver - show the current cpufreq HW/BIOS limitation
+ */
+static ssize_t show_bios_limit(struct cpufreq_policy *policy, char *buf)
+{
+	unsigned int limit;
+	int ret;
+	if (cpufreq_driver->bios_limit) {
+		ret = cpufreq_driver->bios_limit(policy->cpu, &limit);
+		if (!ret)
+			return sprintf(buf, "%u\n", limit);
+	}
+	return sprintf(buf, "%u\n", policy->cpuinfo.max_freq);
+}
 
+#ifdef CONFIG_CPU_FREQ_VDD_LEVELS
+#ifdef CONFIG_MSM_CPU_AVS
+extern ssize_t acpuclk_get_vdd_levels_havs_str(char *buf);
+static ssize_t show_vdd_levels_havs(struct cpufreq_policy *policy, char *buf)
+{
+	return acpuclk_get_vdd_levels_havs_str(buf);
+}
+
+int	atoi(char *string) {
+  int	retCode=0;
+  int	sign=1;
+
+  while (*string != 0) {
+    if (*string=='+') {
+      sign=1;
+    } else if (*string=='-') {
+      sign=-1;
+    } else if ((*string>='0') && (*string<='9')) {
+      retCode *= 10;
+      retCode += *string-'0';
+    } else {
+      break;
+    }
+    string++;
+  }
+
+  retCode *= sign;
+
+  return (retCode);
+}
+
+#define	SEPARATORS	"\t :"
+extern void acpuclk_set_vdd_havs(unsigned acpu_khz, int min_vdd, int max_vdd);
+static ssize_t store_vdd_levels_havs(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+  char	*fields[3]={0};
+  int	f, nbFields=0;
+
+  fields[0]=(char *)buf;
+  for (f=0; (f<count) && (nbFields<3); f++) {
+    if (strchr(SEPARATORS, buf[f]) != NULL) {
+      // new field
+      nbFields++;
+      while ((strchr(SEPARATORS, buf[f])!=NULL) && (f<count)) {
+	f++;
+      }
+      fields[nbFields]=(char *)&buf[f];
+    }
+  }
+  if (f==count) {
+    nbFields++;
+  }
+
+  dprintk("nbFields=%d\n", nbFields);
+  for (f=0; f<nbFields; f++) {
+    dprintk("Field%d=%s - val=%d\n", f, fields[f], atoi(fields[f]));
+  }
+
+  // 2 possibilities. Either we have 2 fields containing +/- values.
+  // Either we have 3 fields containing the frequency, new min, and new max
+  if (nbFields==2) {
+    acpuclk_set_vdd_havs(0, atoi(fields[0]), atoi(fields[1]));
+  } else if (nbFields==3) {
+    acpuclk_set_vdd_havs(atoi(fields[0]), atoi(fields[1]), atoi(fields[2]));
+  }
+
+  return count;
+}
+#else
 extern ssize_t acpuclk_get_vdd_levels_str(char *buf);
 static ssize_t show_vdd_levels(struct cpufreq_policy *policy, char *buf)
 {
-return acpuclk_get_vdd_levels_str(buf);
+	return acpuclk_get_vdd_levels_str(buf);
 }
 
 extern void acpuclk_set_vdd(unsigned acpu_khz, int vdd);
 static ssize_t store_vdd_levels(struct cpufreq_policy *policy, const char *buf, size_t count)
 {
-int i = 0, j;
-int pair[2] = { 0, 0 };
-int sign = 0;
-
-if (count < 1)
-return 0;
-
-if (buf[0] == '-')
-{
-sign = -1;
-i++;
-}
-else if (buf[0] == '+')
-{
-sign = 1;
-i++;
-}
-
-for (j = 0; i < count; i++)
-{
-char c = buf[i];
-if ((c >= '0') && (c <= '9'))
-{
-pair[j] *= 10;
-pair[j] += (c - '0');
-}
-else if ((c == ' ') || (c == '\t'))
-{
-if (pair[j] != 0)
-{
-j++;
-if ((sign != 0) || (j > 1))
-break;
-}
-}
-else
-break;
-}
-
-if (sign != 0)
-{
-if (pair[0] > 0)
-acpuclk_set_vdd(0, sign * pair[0]);
-}
-else
-{
-if ((pair[0] > 0) && (pair[1] > 0))
-acpuclk_set_vdd((unsigned)pair[0], pair[1]);
-else
-return -EINVAL;
-}
-
-return count;
-}
+	int i = 0, j;
+	int pair[2] = { 0, 0 };
+	int sign = 0;
 
-extern unsigned int acpuclk_get_vdd_min(void);
-static ssize_t show_vdd_min(struct cpufreq_policy *policy, char *buf)
-{
-	return sprintf(buf, "%u\n", acpuclk_get_vdd_min());
-}
-
-extern unsigned int acpuclk_get_vdd_max(void);
-static ssize_t show_vdd_max(struct cpufreq_policy *policy, char *buf)
-{
-	return sprintf(buf, "%u\n", acpuclk_get_vdd_max());
-}
+	if (count < 1)
+		return 0;
 
-extern unsigned int acpuclk_get_vdd_step(void);
-static ssize_t show_vdd_step(struct cpufreq_policy *policy, char *buf)
-{
-	return sprintf(buf, "%u\n", acpuclk_get_vdd_step());
-}
+	if (buf[0] == '-')
+	{
+		sign = -1;
+		i++;
+	}
+	else if (buf[0] == '+')
+	{
+		sign = 1;
+		i++;
+	}
 
-#endif
+	for (j = 0; i < count; i++)
+	{
+		char c = buf[i];
+		if ((c >= '0') && (c <= '9'))
+		{
+			pair[j] *= 10;
+			pair[j] += (c - '0');
+		}
+		else if ((c == ' ') || (c == '\t'))
+		{
+			if (pair[j] != 0)
+			{
+				j++;
+				if ((sign != 0) || (j > 1))
+					break;
+			}
+		}
+		else
+			break;
+	}
 
-/**
- * show_scaling_driver - show the current cpufreq HW/BIOS limitation
- */
-static ssize_t show_bios_limit(struct cpufreq_policy *policy, char *buf)
-{
-	unsigned int limit;
-	int ret;
-	if (cpufreq_driver->bios_limit) {
-		ret = cpufreq_driver->bios_limit(policy->cpu, &limit);
-		if (!ret)
-			return sprintf(buf, "%u\n", limit);
+	if (sign != 0)
+	{
+		if (pair[0] > 0)
+			acpuclk_set_vdd(0, sign * pair[0]);
 	}
-	return sprintf(buf, "%u\n", policy->cpuinfo.max_freq);
+	else
+	{
+		if ((pair[0] > 0) && (pair[1] > 0))
+			acpuclk_set_vdd((unsigned)pair[0], pair[1]);
+		else
+			return -EINVAL;
+	}
+
+	return count;
 }
+#endif // AVS
+#endif // VDD_LEVELS
 
 cpufreq_freq_attr_ro_perm(cpuinfo_cur_freq, 0400);
 cpufreq_freq_attr_ro(cpuinfo_min_freq);
@@ -768,11 +817,12 @@ cpufreq_freq_attr_rw(scaling_max_freq);
 cpufreq_freq_attr_rw(scaling_governor);
 cpufreq_freq_attr_rw(scaling_setspeed);
 #ifdef CONFIG_CPU_FREQ_VDD_LEVELS
+#ifdef CONFIG_MSM_CPU_AVS
+cpufreq_freq_attr_rw(vdd_levels_havs);
+#else
 cpufreq_freq_attr_rw(vdd_levels);
-cpufreq_freq_attr_ro(vdd_min);
-cpufreq_freq_attr_ro(vdd_max);
-cpufreq_freq_attr_ro(vdd_step);
-#endif
+#endif // AVS
+#endif // VDD_LEVELS
 
 static struct attribute *default_attrs[] = {
 	&cpuinfo_min_freq.attr,
@@ -787,11 +837,12 @@ static struct attribute *default_attrs[] = {
 	&scaling_available_governors.attr,
 	&scaling_setspeed.attr,
 #ifdef CONFIG_CPU_FREQ_VDD_LEVELS
-	&vdd_levels.attr,
-	&vdd_min.attr,
-	&vdd_max.attr,
-	&vdd_step.attr,
-#endif
+#ifdef CONFIG_MSM_CPU_AVS
+	&vdd_levels_havs.attr,
+#else
+ 	&vdd_levels.attr,
+#endif // AVS
+#endif // VDD_LEVELS
 	NULL
 };
 
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index b99a2a5..c66c227 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -79,6 +79,7 @@ struct cpufreq_real_policy {
 	unsigned int		min;    /* in kHz */
 	unsigned int		max;    /* in kHz */
         unsigned int		policy; /* see above */
+	unsigned int		vdd_levels; /* for CPU_FREQ_VDD_LEVELS */
 	struct cpufreq_governor	*governor; /* see below */
 };
 
@@ -95,6 +96,7 @@ struct cpufreq_policy {
 	unsigned int		cur;    /* in kHz, only needed if cpufreq
 					 * governors are used */
         unsigned int		policy; /* see above */
+	unsigned int		vdd_levels; /* for CPU_FREQ_VDD_LEVELS */
 	struct cpufreq_governor	*governor; /* see below */
 
 	struct work_struct	update; /* if update_policy() needs to be
-- 
1.7.5.4

